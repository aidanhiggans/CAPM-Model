import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

ASSET = ['AAPL']

MARKET_INDEX = '^GSPC'

START_DATE = '2015-01-01'
END_DATE = '2025-01-01'

# Market interest rate
RISK_FREE_RATE = 0.02
MONTHLY_RISK_FREE_RATE = RISK_FREE_RATE / 12

WEIGHTS = [1]

# Making sure that portfolio weights are equal to 1
if not np.isclose(sum(WEIGHTS), 1.0):
    raise ValueError("Portfolio weights must sum to 1. Current sum: {}".format(sum(WEIGHTS)))

class CAPM:

    # Object-oriented programming is used through the definition of a class object called CAPM
    # Parameters of the class are assets, start date, and end date
    def __init__(self, assets, start_date, end_date):
        self.data = None
        self.assets = assets
        self.start_date = start_date
        self.end_date = end_date

    def download_data(self):

        # Dictionary is used to store asset information as key value pairs
        # The asset ticker is the key and the Adjusted Closing Price is the value
        data = {}

        for asset in self.assets:
            ticker = yf.download(asset, self.start_date, self.end_date, auto_adjust=False)
            # Adjusted Closing Prices are used as it is more accurate since it captures factors such as dividends and stock splits
            data[asset] = ticker['Adj Close']
        return pd.concat(data, axis=1)

    def initialize(self):

        # Asset daily returns are downloaded as a pandas dataframe
        asset_data = self.download_data()
        # Monthly returns are to be used instead of daily returns
        # This is because in this case we are dealing with long term investing rather than short term investing
        # Monthly returns are approximately normally distributed
        # Hence monthly returns are used since the CAPM model assumes that the returns are normalized
        # The daily returns are grouped by month through the resample code, whilst last() returns the month end closing price of the asset
        asset_data = asset_data.resample('ME').last()

        # When downloading data, there is an issue that resulting DataFrame returns two levels of column names
        # Pandas expects simple columns
        # To counter this problem, the column MultiIndex is flattened into a single level
        if isinstance(asset_data.columns, pd.MultiIndex):
            asset_data.columns = asset_data.columns.get_level_values(0)

        market_prices = asset_data[MARKET_INDEX]
        asset_prices = asset_data.drop(columns=[MARKET_INDEX])

        # Calculating logarithmic monthly returns
        # To calculate logarithmic monthly returns the formula ln(s(t)/s(t-1)) is used
        # This is captured by using shift
        market_returns = np.log(market_prices / market_prices.shift(1))
        assets_returns = np.log(asset_prices / asset_prices.shift(1))

        # Computing the portfolio using weights
        if len(WEIGHTS) != len(asset_prices.columns):
            raise ValueError("Number of weights must be equal to number of assets")
        portfolio_returns = (assets_returns * WEIGHTS).sum(axis=1)

        # Storing the data
        self.data = pd.DataFrame({'portfolio_returns': portfolio_returns, 'market_returns': market_returns}).dropna()
        print(self.data.head())

    def asset_metrics(self):
        mean_asset_returns = self.data['portfolio_returns'].mean()
        variance_asset = self.data['portfolio_returns'].var()
        std_dev_asset = np.sqrt(variance_asset)

        # Annualizing the metrics
        annual_asset_return = mean_asset_returns * 12
        annual_asset_volatility = std_dev_asset * np.sqrt(12)

        # Calculating Sharpe Ratio as Annual Return - Risk Free Rate / Volatility
        sharpe_ratio = ((annual_asset_return - RISK_FREE_RATE) / annual_asset_volatility)

        # Printing the metrics
        print("Realized Annual Asset Returns:", annual_asset_return)
        print("Annual Asset Volatility:", annual_asset_volatility)
        print("Sharpe Ratio:", sharpe_ratio)

    def calculate_beta(self):
        # Beta is the variable that is defined as how risky the asset/portfolio is relative to the market
        # Beta = 1 then asset moves exactly with the market
        # Beta > 1 then asset risk relative to market is higher than that of an average asset
        # Beta < 1 then asset risk relative to market is less than that of an average asset
        # Beta formula is as follows: Beta = Covariance(Return of Asset, Return of Market) / Variance(Market)
        # In the covariance matrix, the values along the main diagonal are the variances (covariance of the values with themselves is the same as the variance)
        # Values not in the main diagonal are the covariances
        # The covariance matrix is also symmetric, so cov[0,1] = cov[1,0]
        # The covariance matrix will work something like this:       | Asset | Market
        #                                                      Asset | [0,0] | [0,1]
        #                                                      Market| [1,0] | [1,1]     Here the values represent the index/position of the value inside the covariance matrix
        # So [0,0] is the variance of the Asset (which we do not need)
        # Covariance of the Market with the Asset is the same as covariance of the Asset with the Market hence this is why [0,1] = [1,0]
        # Finally [1,1] is the variance of the Market
        covariance_matrix = np.cov(self.data['portfolio_returns'], self.data['market_returns'])
        beta = covariance_matrix[0, 1] / covariance_matrix[1, 1]
        print("Beta calculated through formula:", beta)

    def regression(self):
        # Linear regression will be used to fit a line to the data
        # The formula for CAPM is as follows: E[ra] = rf + beta*(E[rm]-rf)
        # CAPM formula will be modified slightly to also include alpha
        # New formula is E[ra] - rf = beta*(E[rm] - rf) + alpha where alpha is the abnormal return not explained by the market
        # In other words alpha is the value by which the actual return outperforms/underperforms the expected return (the return predicted by the CAPM Model)
        # This formula gives the equation of a line y = mx + c
        # In this case the plot will be expected asset_returns (minus rf) against expected market_returns (minus rf) where beta will be the gradient and alpha will be the y-intercept
        # If alpha = 0, then the asset lies on the CAPM Line and all the return is explained by the market risk
        # If alpha > 0, then asset lies above CAPM Line and that means that the asset has outperformed the expected return
        # If alpha < 0, then asset lies below CAPM Line and that means that the asset has underperformed the expected return
        # Degree is equal to 1 since a line will be plotted
        market_excess = self.data["market_returns"] - MONTHLY_RISK_FREE_RATE
        asset_excess = self.data["portfolio_returns"] - MONTHLY_RISK_FREE_RATE
        beta, alpha = np.polyfit(market_excess,asset_excess, deg=1)
        print("Beta calculated through regression:", beta)
        print("Alpha:", alpha)
        # Expected return will be calculated using the CAPM formula
        # We are dealing with monthly returns, so to capture annual returns we need to multiply monthly returns by 12
        expected_monthly_return = MONTHLY_RISK_FREE_RATE + beta * (self.data['market_returns'].mean() - MONTHLY_RISK_FREE_RATE)
        expected_annual_return = expected_monthly_return * 12
        print("Expected Annual Return of Asset:", expected_annual_return)
        self.plot_regression(alpha, beta)

    def plot_regression(self, alpha, beta):
        excess_market = self.data["market_returns"] - MONTHLY_RISK_FREE_RATE
        excess_asset = self.data["portfolio_returns"] - MONTHLY_RISK_FREE_RATE
        fig, axis = plt.subplots(1, figsize = (20,10))
        axis.scatter(excess_market, excess_asset, label = "Excess Return Data Points", alpha = 0.6)
        capm_line = beta * excess_market + alpha
        axis.plot(excess_market, capm_line, color = 'red', label = "CAPM Regression Line")
        plt.title('Capital Asset Pricing Model (CAPM) - Finding Alphas and Betas')
        plt.xlabel('Market Return $R_m$', fontsize = 18)
        plt.ylabel('Asset Return $R_a$')
        plt.text(0.05, 0.01,rf'$R_a - R_f = {beta:.2f} (R_m - R_f) + {alpha * 100:.2f}\%$', fontsize=14, bbox=dict(facecolor='white', alpha=0.5))
        plt.grid(True)
        plt.show()

if __name__ == '__main__':

    capm = CAPM(ASSET + [MARKET_INDEX], START_DATE, END_DATE)
    capm.initialize()

    capm.asset_metrics()
    capm.calculate_beta()
    capm.regression()
