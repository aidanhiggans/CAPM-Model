import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

ASSET = ['AAPL', 'WMT', 'TSLA', 'MSFT', 'UNH', 'JPM']

MARKET_INDEX = '^GSPC'

START_DATE = '2015-01-01'
END_DATE = '2025-01-01'

RISK_FREE_RATE = 0.02
MONTHLY_RISK_FREE_RATE = RISK_FREE_RATE / 12

WEIGHTS = [0.2, 0.2, 0.12, 0.2, 0.2, 0.08]

if not np.isclose(sum(WEIGHTS), 1.0):
    raise ValueError("Portfolio weights must sum to 1. Current sum: {}".format(sum(WEIGHTS)))

class CAPM:

    # Object-oriented programming is used through the definition of a class object called CAPM
    def __init__(self, assets, start_date, end_date):
        self.data = None
        self.assets = assets
        self.start_date = start_date
        self.end_date = end_date

    def download_data(self):

        data = {}

        for asset in self.assets:
            ticker = yf.download(asset, self.start_date, self.end_date, auto_adjust=False)
            data[asset] = ticker['Adj Close']
        return pd.concat(data, axis=1)

    def initialize(self):

        asset_data = self.download_data()
        asset_data = asset_data.resample('ME').last()

        # When downloading data, there is an issue that resulting DataFrame returns two levels of column names
        # Pandas expects simple columns
        # To counter this problem, the column MultiIndex is flattened into a single level
        if isinstance(asset_data.columns, pd.MultiIndex):
            asset_data.columns = asset_data.columns.get_level_values(0)

        market_prices = asset_data[MARKET_INDEX]
        asset_prices = asset_data.drop(columns=[MARKET_INDEX])

        # Calculating logarithmic monthly returns
        # To calculate logarithmic monthly returns the formula ln(s(t)/s(t-1)) is used
        market_returns = np.log(market_prices / market_prices.shift(1))
        assets_returns = np.log(asset_prices / asset_prices.shift(1))

        # Computing the portfolio using weights
        if len(WEIGHTS) != len(asset_prices.columns):
            raise ValueError("Number of weights must be equal to number of assets")
        portfolio_returns = (assets_returns * WEIGHTS).sum(axis=1)

        self.data = pd.DataFrame({'portfolio_returns': portfolio_returns, 'market_returns': market_returns}).dropna()
        print(self.data.head())

    def asset_metrics(self):
        mean_asset_returns = self.data['portfolio_returns'].mean()
        variance_asset = self.data['portfolio_returns'].var()
        std_dev_asset = np.sqrt(variance_asset)

        annual_asset_return = mean_asset_returns * 12
        annual_asset_volatility = std_dev_asset * np.sqrt(12)

        # Calculating Sharpe Ratio as Annual Return - Risk Free Rate / Volatility
        sharpe_ratio = ((annual_asset_return - RISK_FREE_RATE) / annual_asset_volatility)

        print("Realized Annual Asset Returns:", annual_asset_return)
        print("Annual Asset Volatility:", annual_asset_volatility)
        print("Sharpe Ratio:", sharpe_ratio)

    def calculate_beta(self):
        # In the covariance matrix, the values along the main diagonal are the variances (covariance of the values with themselves is the same as the variance)
        # Values not in the main diagonal are the covariances
        # The covariance matrix is also symmetric, so cov[0,1] = cov[1,0]
        # The covariance matrix will work something like this:       | Asset | Market
        #                                                      Asset | [0,0] | [0,1]
        #                                                      Market| [1,0] | [1,1]     Here the values represent the index/position of the value inside the covariance matrix
        # So [0,0] is the variance of the Asset (which we do not need)
        # Covariance of the Market with the Asset is the same as covariance of the Asset with the Market hence this is why [0,1] = [1,0]
        # Finally [1,1] is the variance of the Market
        covariance_matrix = np.cov(self.data['portfolio_returns'], self.data['market_returns'])
        beta = covariance_matrix[0, 1] / covariance_matrix[1, 1]
        print("Beta calculated through formula:", beta)

    def regression(self):
        market_excess = self.data["market_returns"] - MONTHLY_RISK_FREE_RATE
        asset_excess = self.data["portfolio_returns"] - MONTHLY_RISK_FREE_RATE
        beta, alpha = np.polyfit(market_excess,asset_excess, deg=1)
        print("Beta calculated through regression:", beta)
        print("Alpha:", alpha)
        expected_monthly_return = MONTHLY_RISK_FREE_RATE + beta * (self.data['market_returns'].mean() - MONTHLY_RISK_FREE_RATE)
        expected_annual_return = expected_monthly_return * 12
        print("Expected Annual Return of Asset:", expected_annual_return)
        self.plot_regression(alpha, beta)

    def plot_regression(self, alpha, beta):
        excess_market = self.data["market_returns"] - MONTHLY_RISK_FREE_RATE
        excess_asset = self.data["portfolio_returns"] - MONTHLY_RISK_FREE_RATE
        fig, axis = plt.subplots(1, figsize = (20,10))
        axis.scatter(excess_market, excess_asset, label = "Excess Return Data Points", alpha = 0.6)
        capm_line = beta * excess_market + alpha
        axis.plot(excess_market, capm_line, color = 'red', label = "CAPM Regression Line")
        plt.title('Capital Asset Pricing Model (CAPM) - Finding Alphas and Betas')
        plt.xlabel('Market Return $R_m$', fontsize = 18)
        plt.ylabel('Asset Return $R_a$')
        plt.text(0.05, 0.01,rf'$R_a - R_f = {beta:.2f} (R_m - R_f) + {alpha * 100:.2f}\%$', fontsize=14, bbox=dict(facecolor='white', alpha=0.5))
        plt.grid(True)
        plt.show()

if __name__ == '__main__':

    capm = CAPM(ASSET + [MARKET_INDEX], START_DATE, END_DATE)
    capm.initialize()

    capm.asset_metrics()
    capm.calculate_beta()
    capm.regression()
